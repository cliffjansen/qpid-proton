--- impls/quiver-arrow-qpid-proton-c.c.cj0	2022-07-25 12:19:19.734907629 -0400
+++ impls/quiver-arrow-qpid-proton-c.c	2022-08-23 13:10:51.188076997 -0400
@@ -42,6 +42,7 @@
 #include <string.h>
 #include <time.h>
 #include <inttypes.h>
+#include <unistd.h>
 
 static const pn_bytes_t SEND_TIME = { sizeof("SendTime") - 1, "SendTime" };
 
@@ -86,6 +87,24 @@
     size_t received;
     size_t acknowledged;
     pn_ssl_domain_t *ssl_domain;
+    int batch_count;
+    int biggest_batch;
+    time_t end_time;
+    uint64_t start_tt;
+    uint64_t end_tt;
+    size_t chunk_size;  // max bytes to send or receive before synch with peer (read and write flush)
+    size_t bytes_unacked;
+    pn_link_t *sender_link;
+    pn_session_t *sender_session;
+    int stalls;
+    uint64_t stall_ticks;
+    uint64_t stall_start;
+    int flushes;
+    int max_credit;
+    int last_credit;
+    int wakes;
+    int wasted_batch_count;
+    int chunks_this_batch;
 };
 
 void fail_(const char* file, int line, const char* fmt, ...) {
@@ -135,6 +154,16 @@
     return t.tv_sec * 1000 + t.tv_nsec / (1000 * 1000);
 }
 
+// debug clock
+uint64_t hrtick(void) {
+  uint32_t lo, hi;
+  __asm__ volatile ("rdtscp"
+      : /* outputs */ "=a" (lo), "=d" (hi)
+      : /* no inputs */
+      : /* clobbers */ "%rcx");
+  return (uint64_t)lo | (((uint64_t)hi) << 32);
+}
+
 static const size_t BUF_MIN = 1024;
 
 // Ensure buf has at least size bytes, use realloc if need be
@@ -246,6 +275,31 @@
     printf("%" PRId64 ",0\n", stime);
 }
 
+static void try_sending(struct arrow* a) {
+    // send a chunk, wake self if unused credit
+    pn_link_t* link = a->sender_link;
+    size_t max_bytes = a->chunk_size;
+    a->chunks_this_batch++;
+    if (a->chunks_this_batch > 1)
+      return;
+
+    while (pn_link_credit(link) > 0) {
+        if (a->desired_count > 0 && a->sent == a->desired_count) {
+            break;
+        }
+        send_message(a, link);
+        // we use one link per session, but it may be backed up by session window
+        size_t tp_pending = pn_session_outgoing_bytes(a->sender_session);
+        if (tp_pending > max_bytes) {
+            break;
+        }
+    }
+    if (pn_link_credit(link) == 0 && a->stall_start == 0) {
+        a->stalls++;
+        a->stall_start = hrtick();
+    }
+}
+
 static void fail_if_condition(pn_event_t* e, pn_condition_t* cond) {
     if (pn_condition_is_set(cond)) {
         FAIL("%s: %s: %s", pn_event_type_name(pn_event_type(e)),
@@ -324,7 +378,8 @@
         break;
     }
     case PN_CONNECTION_REMOTE_OPEN: {
-        pn_connection_open(pn_event_connection(e)); // Return the open if not already done
+        a->connection = pn_event_connection(e);
+        pn_connection_open(a->connection); // Return the open if not already done
         break;
     }
     case PN_SESSION_REMOTE_OPEN:
@@ -339,22 +394,35 @@
         pn_link_open(l);
         if (pn_link_is_receiver(l)) {
             pn_link_flow(l, a->credit_window);
+        } else {
+            a->sender_link = l;
+            a->sender_session = pn_link_session(l);
         }
         break;
     }
+    case PN_CONNECTION_WAKE: {
+        a->wakes++;
+        try_sending(a);
+        break;
+    }
     case PN_LINK_FLOW: {
-        pn_link_t* link = pn_event_link(e);
-
-        if (pn_link_is_sender(link)) {
-            while (pn_link_credit(link) > 0) {
-                if (a->desired_count > 0 && a->sent == a->desired_count) {
-                    break;
+        pn_link_t* l = pn_event_link(e);
+        if (pn_link_is_sender(l)) {
+            int cr = pn_link_credit(l);
+            if (cr > 0) {
+                if (a->max_credit == 0) {
+                    a->max_credit = cr;
+                }
+                if (cr > a->last_credit) {
+                    // Ignore local generated flow events that don't change credit
+                    if (a->stall_start) {
+                        a->stall_ticks += hrtick() - a->stall_start;
+                        a->stall_start = 0;
+                    }
+                    try_sending(a);
                 }
-
-                send_message(a, link);
             }
         }
-
         break;
     }
     case PN_DELIVERY: {
@@ -379,6 +447,7 @@
 
             // Message received
 
+            a->bytes_unacked += pn_delivery_pending(delivery);
             decode_message(a->message, delivery, &a->buffer);
             process_message(a, a->message);
 
@@ -393,6 +462,11 @@
             }
 
             pn_link_flow(link, a->credit_window - pn_link_credit(link));
+            if (a->bytes_unacked > a->chunk_size) {
+                a->bytes_unacked = 0;
+                pn_connection_write_pending(pn_event_connection(e));
+                a->flushes++;
+            }
         } else {
             FAIL("Unexpected");
         }
@@ -460,17 +534,45 @@
     while (true) {
         pn_event_batch_t* events = pn_proactor_wait(a->proactor);
         pn_event_t* e;
+        a->batch_count++;
+        a->chunks_this_batch = 0;
+        a->bytes_unacked = 0;
+        int event_count = 0;
 
         for (e = pn_event_batch_next(events); e; e = pn_event_batch_next(events)) {
+            event_count++;
             if (!handle(a, e)) {
                 return;
             }
         }
 
+        if (a->sender_link) {
+            if (a->chunks_this_batch == 0)
+                a->wasted_batch_count++; // wakeup with batch consisting solely of self generated FLOW/TRANSPORT
+            a->last_credit = pn_link_credit(a->sender_link);
+            if (a->last_credit > 0) {
+                // wake self to resume sending "soon".  write flush happens in interrim.
+                pn_connection_wake(a->connection);
+            }
+        }
+
         pn_proactor_done(a->proactor, events);
+        if (event_count > a->biggest_batch) a->biggest_batch = event_count;
     }
 }
 
+size_t envcheck(const char* env_name, size_t default_value) {
+    const char* env_value = getenv(env_name);
+    if (env_value) {
+        int v = atoi(env_value);
+        if (v >= 0 && v < (100 * 1024 *1024))
+            return (size_t) v;
+        else
+            FAIL("Error bad environment value: %s %s", env_name, env_value);
+    }
+    return default_value;
+}
+
 int token(const char* names[], const char* name) {
     size_t i = 0;
     for (; names[i] && strcmp(names[i], name); i++)
@@ -535,6 +637,8 @@
     }
     a.tls = strcmp(a.scheme, "amqps") == 0;
 
+    a.chunk_size = envcheck("QVRCHUNK", 32000);
+
     // Set up the fixed parts of the message
     a.message = pn_message();
     pn_message_set_durable(a.message, a.durable);
@@ -570,13 +674,30 @@
     }
 
     a.start_time = now();
+    a.start_tt = hrtick();
 
     run(&a);
 
+    a.end_tt = hrtick();
+    a.end_time = now();
     if (a.ssl_domain) pn_ssl_domain_free(a.ssl_domain);
     if (a.message) pn_message_free(a.message);
     if (a.proactor) pn_proactor_free(a.proactor);
     free(a.buffer.start);
 
+    if (envcheck("QVRDUMP", 0) == 1) {
+        char dfn[120];
+        sprintf(dfn, "/tmp/qvrxx.%d.%c", getpid(), (a.connection_mode == CLIENT) ? 's' : 'r');
+        FILE *fp = fopen(dfn, "w");
+        if (fp) {
+            fprintf(fp, "%c %" PRIu64 " %" PRIu64 "    %d  t4\n", (a.connection_mode == CLIENT) ? 'S' : 'R',
+                    a.end_time - a.start_time,
+                    a.end_tt - a.start_tt,
+                    a.batch_count);
+            fprintf(fp, "stalls %d %u       flushes %d  biggest %d    wasted batch %d wakes %d\n", a.stalls, (unsigned) a.stall_ticks,
+                    a.flushes, a.biggest_batch, a.wasted_batch_count, a.wakes);
+            fclose(fp);
+        }
+    }
     return 0;
 }
